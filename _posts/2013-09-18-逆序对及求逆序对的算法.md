---
layout: post
categories: [algorithms]
tags: [algorithms, 逆序数，归并排序]
---

###{{ page.title }}###


>**逆序对：**  
>设 A 为一个有 n 个数字的有序集 (n>1)，其中所有数字各不相同。  
>如果存在正整数 i, j 使得 1 ≤ i < j ≤ n 而且 A[i] > A[j]，则 <A[i], A[j]> 这个有序对就为 A 的一个逆序对，也称作逆序数。  
>例如：数组 <2,3,8,6,1> 的逆序对为：<2,1> <3,1> <8,6> <8,1> <6,1> 总数共5个。  

以上是来自维基百科对逆序对的定义。有定理：  

>$$n$$个不同的数做排列$$p_1p_2p_3...p_n$$，这个排列中逆序对的个数为  

$$
t = t_1 + t_2 + t_3 + ... + t_n = \sum_{i=1}^n{t_i}
$$

>$$t_i$$为排列中位于$$p_i$$前且小于$$p_i$$的数的个数  


根据此定理,很容易求出一个排列中逆序数的个数，例如：排列 2 5 3 9 7 6 中，$$t_1=0,t_2=0,t_3=1,t_4=0,t_5=1,t_6=2$$,这个排列中逆序数的个数为$$0+0+1+0+1+2=4$$。  
这个可以作为求逆序对个数的基本算法  
{% highlight cpp linenos %}
int nixu(int arr[], int len)
{
    int i, j;
    int sum = 0;

    for (i = 0; i < len; ++i)
    {
        for (j = 0; j < i; ++j)
        {
            if (arr[j] > arr[i])
                sum += 1;
        }
    }

    return sum;
}
{% endhighlight %}

很容易得到这个算法的时间复杂度是$$\Theta(n^2)$$。
在《算法导论》第2章有个思考题是关于逆序对的，问插入排序的运行时间和输入数组中逆序对的个数是什么关系，这个不难证明，两者是相等的。简单说明如下：  
将数字$$a$$插入升序排列的数组$$a_1a_2...a_n$$中，需要先在数组中找到要插入的位置，假设$$a_i<a<a_{i+1}$$,则$$a_{i+1}a_{i+2}...a_n$$都需要依此向后移动一个位置，移动的次数为$$n-i$$。而序列$$a_1a_2...a_na$$的逆序对的个数$$n-i$$，和插入排序移动的次数是相等的。因此对插入排序算法稍加改造就可以用来求序列的逆序对个数，但时间复杂度同样是$$\Theta(n^2)$$，所以有必要考虑其他的方法。  
书上提到了用归并排序算法，归并排序的时间复杂度是$$\Theta(nlgn)$$。理解了分治法的原理，再参考归并排序，这个问题很好解决。  
**分解：**将待分析序列分为$$L$$和$$R$$两部分。  
**解决：**原序列的逆序对个数为$$f(A)$$，分解后两个序列的逆序对个数分别为$$f(L)$$和$$f(R)$$，有$$f(A)=f(L)+f(R)+S(L,R)$$，其中$$S(R)$$为L和R共同构成的逆序对的个数。$$f(L)$$和$$f(R)$$可以递归分解至求单个元素的序列逆序对个数，$$S(L,R)$$可在合并的时候求出。  
**合并：**将两个已经求出逆序对个数并且完成排序的序列合并。  
{% highlight cpp linenos %}
#include <stdio.h>

int count = 0;	//用于逆序对的计数

void merge(int A[], int p, int m, int q)
{
    int L[100];
    int R[100];
    int l, r;
    int i = 0, j = 0;

    l = m - p + 1;
    r = q - m;
    while(i < l)
        L[i++] = A[p+i];
    while(j < r)
        R[j++] = A[m+j+1];

    i = j = 0;
    while(i < l && j < r)
    {
        if (L[i] < R[j])
            A[p+i+j] = L[i++];
        else 
        {
			count += (l-i);		//计算R中每个元素的逆序数
            A[p+i+j] = R[j++];
        }
    }
    while (i < l)
        A[p+i+j] = L[i++];
    while (j < r)
        A[p+i+j] = R[j++];
}


void get_inversion_by_mergesort(int A[], int l, int r)
{
    int mid = 0;

	if (l < r)
    {
        mid = (l + r) / 2;
        get_inversion_by_mergesort(A, l, mid);
        get_inversion_by_mergesort(A, mid+1, r);
        merge(A, l, mid, r);
    }
}

int main(void)
{
    int A[10] = {5, 2, 6, 7, 1, 4, 9, 8, 0, 3};

    get_inversion_by_mergesort(A, 0, 9);
    printf("%d\n", count);
	for (int i = 0; i < 10; ++i)
		printf("%d ", A[i]);

    return 0;
}
{% endhighlight %}
