---
layout: post
categories: [Linux编程, Linux内核]
tags: [Linux编程, Linux内核, 亲缘性, CPU掩码]
title: 内核驱动编程实现CPU分域
---

{% include JB/setup %}

####原理

在实时系统中，会要求实时任务能得到及时响应，并且对实时任务的处理具有可预测性，而通用的Linux操作系统，在2.6以后的内核，都具有负载均衡机制，这个机制使每个CPU上的负载都趋于平衡，当这个机制被触发时，负载不均衡的CPU上任务会发生迁移，这样就给实时任务的处理带来了不确定性。所以我们需要想办法避免系统对实时任务采用负载均衡机制。

在进程结构体task_struct中有一个字段cpus_allowed，是cpumask_t结构体类型的，限制了该进程的调度域，指明这个任务可以由哪几个CPU处理。当负载均衡机制被触发时，该进程就允许在这几个CPU上迁移。如果我通过设置cpus_allowed，使实时任务的调度域只包含一个CPU，那么即便触发了负载均衡机制，实时任务也不会被迁移到其他CPU。同时将所有非实时任务的cpus_allowed限定为其他CPU，这样把实时任务和非实时任务的调度域划分开来，非实时任务就不会对实时任务造成影响。

####实现

我本机是4核，把0号CPU做为实时调度域，1～3号CPU做为非实时调度域。我需要完成的工作，是在加载内核驱动中，遍历所有进程，将其cpus_allowed设定至1～3号CPU。卸载驱动是能够把非实时进程的cpus_allowed恢复至默认状态。


