<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0">
<channel>
        <title>Chen Jie</title>
        <description>Chen Jie - Chen Jie</description>
        <link></link>
        <link></link>
        <lastBuildDate>2013-07-25T20:11:35+08:00</lastBuildDate>
        <pubDate>2013-07-25T20:11:35+08:00</pubDate>
        <ttl>1800</ttl>


        <item>
                <title>C语言中#if和#endif预处理指令</title>
                <description>&lt;p&gt;C语言中可以使用条件语句对预处理本身进行控制。这种方式为在编译过程中根据计算所得的条件值选择性地包含不同代码提供了一种手段。最常用的有一下几种：&lt;br&gt;
1.#if !defined() 与#ifndef
这个一般用于保证头文件只被包含一次。&lt;/p&gt;

&lt;h1&gt;if !defined(HDR)&lt;/h1&gt;

&lt;h1&gt;define HDR&lt;/h1&gt;

&lt;p&gt;/* hdr.h文件的内容放在这里 */&lt;/p&gt;

&lt;h1&gt;endif&lt;/h1&gt;

&lt;p&gt;第一次包含hdr.h时，将定义名字HDR，此后再次包含该头文件时，会发现该名字已经定义，就直接跳到#endif处。
C语言专门定义了两个预处理语句#ifdef与#ifndef，用来测试某个名字是否定义。上边的例子等价与&lt;/p&gt;

&lt;h1&gt;ifndef HDR&lt;/h1&gt;

&lt;h1&gt;define HDR&lt;/h1&gt;

&lt;p&gt;/* hdr.h文件的内容放在这里 */&lt;/p&gt;

&lt;h1&gt;endif&lt;/h1&gt;

&lt;p&gt;2.#if 判断式
根据预定义的LEVEL值，判断条件满足的语句才会被编译。&lt;/p&gt;

&lt;h1&gt;define LEVEL 1&lt;/h1&gt;

&lt;h1&gt;ifdef LEVEL&lt;/h1&gt;

&lt;h1&gt;if (LEVEL &amp;gt; 0) &amp;amp;&amp;amp; (LEVEL &amp;lt; 2)&lt;/h1&gt;

&lt;p&gt;printf(&amp;quot;Debugging level 1&amp;quot;);&lt;/p&gt;

&lt;h1&gt;elif (LEVEL &amp;gt; 1) &amp;amp;&amp;amp; (LEVEL &amp;lt; 3)&lt;/h1&gt;

&lt;p&gt;printf(&amp;quot;Debugging level 2&amp;quot;);&lt;/p&gt;

&lt;h1&gt;elif (LEVEL &amp;gt; n-1) &amp;amp;&amp;amp; (LEVEL &amp;lt; n)&lt;/h1&gt;

&lt;p&gt;printf(&amp;quot;Debugging level n&amp;quot;);&lt;/p&gt;

&lt;h1&gt;endif&lt;/h1&gt;

&lt;h1&gt;endif&lt;/h1&gt;

&lt;p&gt;3.#if DEBUG
这一个经常被用来调试，在代码中添加一些打印信息是最常用的一种调试手段，但最终删除用来调试的打印信息却比较麻烦，这中方法可以帮我们很好地解决。看段代码test.c：&lt;/p&gt;

&lt;h1&gt;include &lt;stdio.h&gt;&lt;/h1&gt;

&lt;p&gt;int count(num){
    int count = 0;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;while(num){
    count++;
    num = num &amp;amp; (num-1);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h1&gt;if DEBUG&lt;/h1&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;    printf(&amp;quot;%d %d\n&amp;quot;, count, num);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h1&gt;endif&lt;/h1&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;}

return count;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;int main(void)
{
    int num = 10;
    printf(&amp;quot;%d\n&amp;quot;, count(num));&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;return 0;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;}
用gcc test.c -o test -DDEBUG=1编译，会把#if DEBUG之间的代码编译进去，./test执行后显示
1 8
2 0
2
调试没问题之后，直接gcc test.c -o test就ok了，这样不会把用于调试的那句printf编译进去，当然也不会打印出来。
另外还有一种方法，调试的时候，在test.c开头加上&lt;/p&gt;

&lt;h1&gt;define DEBUG 1&lt;/h1&gt;

&lt;p&gt;调试结束注释掉这句就OK了。这中方法在编译的时候就不需要使用-DDEBUG这个参数了&lt;/p&gt;

&lt;p&gt;4.#if 0
先上代码：&lt;/p&gt;

&lt;h1&gt;if 0&lt;/h1&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;code
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h1&gt;endif&lt;/h1&gt;

&lt;p&gt;在编译时，code部分会被忽略。于是我们就可以用这种方式进行代码注释，这样有两个好处，一是可以用作注释以解决C标准中/&lt;strong&gt;......&lt;/strong&gt;/不能嵌套的缺陷；二是code部分很长的时候要比/&lt;em&gt;......&lt;/em&gt;/更方便。在修改代码的时候，很多时候我们写的代码可能不许要了，但又不忍心删掉，这样注释是最好的办法。&lt;br&gt;
当然，把if后的0改为1，code部分就恢复作用。&lt;/p&gt;
</description>
                <link>/C%E8%AF%AD%E8%A8%80%E4%B8%AD%23if%E5%92%8C%23endif%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4.html</link>
                <guid>/C语言中#if和#endif预处理指令</guid>
                <pubDate>2013-07-16T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>安装windows7和ubuntu双系统所遇问题及解决方法</title>
                <description></description>
                <link>/%E5%AE%89%E8%A3%85windows7%E5%92%8Cubuntu%E5%8F%8C%E7%B3%BB%E7%BB%9F%E6%89%80%E9%81%87%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95.html</link>
                <guid>/安装windows7和ubuntu双系统所遇问题及解决方法</guid>
                <pubDate>2013-07-15T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Linux系统编程时间函数</title>
                <description>&lt;p&gt;在linux系统中，关于时间的函数有连个，分别是&lt;code&gt;clock_gettime()&lt;/code&gt;和&lt;code&gt;gettimeofday()&lt;/code&gt;。&lt;/p&gt;

&lt;h4&gt;关于&lt;code&gt;clock_gettime()&lt;/code&gt;&lt;/h4&gt;

&lt;h2&gt;1. 函数原型:    &lt;/h2&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;#include &amp;lt;time.h&amp;gt;
int clock_gettime(clockid_t clk_id, struct timespec *tp);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;2. 说明：    &lt;/h2&gt;

&lt;p&gt;&lt;code&gt;clock_gettime&lt;/code&gt;把当前时间用tp结构体返回，返回的时间会根据clk_id的不同而相应变化。&lt;/p&gt;

&lt;h2&gt;3. 结构体及参数：&lt;/h2&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;struct timespec {
    time_t   tv_sec;        /* seconds */
    long     tv_nsec;       /* nanoseconds */
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;clock_gettime&lt;/code&gt;调用之后，会把获取的时间存储在结构体tp中，获取的时间即为&lt;code&gt;tp-&amp;gt;tv_sev(单位为s)+tp-&amp;gt;tv_nsec(单位为ns)&lt;/code&gt;，获取的时间根据参数clk_id计算。&lt;/p&gt;

&lt;p&gt;参数clk_id有如下几个：&lt;br&gt;
&lt;code&gt;CLOCK_REALTIME:&lt;/code&gt;随系统实时时间改变而改变,即从UTC1970-1-1 0:0:0开始到当前系统时间所经历的ns数，如果当前时间被修改，则得到的结果也发生变化。&lt;br&gt;
&lt;code&gt;CLOCK_MONOTONIC:&lt;/code&gt;从系统启动那一刻起开始计时,不受系统当前时间被用户该免的影响&lt;br&gt;
&lt;code&gt;CLOCK_PROCESS_CPUTIME_ID:&lt;/code&gt;本进程到当前代码系统CPU花费的时间&lt;br&gt;
&lt;code&gt;CLOCK_THREAD_CPUTIME_ID:&lt;/code&gt;本线程到当前代码系统CPU花费的时间    &lt;/p&gt;

&lt;h4&gt;关于函数gettimeofday&lt;/h4&gt;

&lt;h2&gt;1. 函数原型：&lt;/h2&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;#include&amp;lt;sys/time.h&amp;gt;
int gettimeofday(struct  timeval*tv,struct  timezone *tz )
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;2. 说明：&lt;/h2&gt;

&lt;p&gt;gettimeofday会把目前的时间用tv 结构体返回，当地时区的信息则放到tz所指的结构中&lt;/p&gt;

&lt;h2&gt;3. 结构体及参数：&lt;/h2&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;struct  timeval{
    long  tv_sec;    /*秒*/
    long  tv_usec;   /*微妙*/
}；

struct  timezone{
    int tz_minuteswest;     /*和greenwich 时间差了多少分钟*/
    int tz_dsttime;         /*type of DST correction*/
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在使用gettimeofday时，第二个参数一般都为空，不需要获得timezone的值。&lt;/p&gt;

&lt;h2&gt;程序实例time.c：&lt;/h2&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;time.h&amp;gt;
#include &amp;lt;sys/time.h&amp;gt;
int main()
{
    struct timespec ts;
    struct timeval tv;

    printf(&amp;quot;********clock_gettime********\n&amp;quot;);
    clock_gettime(CLOCK_REALTIME, &amp;amp;ts);
    printf(&amp;quot;CLOCK_REALTIME: %ld: %ld\n&amp;quot;, ts.tv_sec, ts.tv_nsec);
    clock_gettime(CLOCK_MONOTONIC, &amp;amp;ts);
    printf(&amp;quot;CLOCK_MONOTONIC: %ld: %ld\n&amp;quot;, ts.tv_sec, ts.tv_nsec);
    clock_gettime(CLOCK_PROCESS_CPUTIME_ID, &amp;amp;ts);
    printf(&amp;quot;CLOCK_PROCESS_CPUTIME_ID: %ld: %ld\n&amp;quot;, ts.tv_sec, ts.tv_nsec);
    clock_gettime(CLOCK_THREAD_CPUTIME_ID, &amp;amp;ts);
    printf(&amp;quot;CLOCK_THREAD_CPUTIME_ID: %ld: %ld\n&amp;quot;, ts.tv_sec, ts.tv_nsec);

    printf(&amp;quot;*******gettimeofday*********\n&amp;quot;);
    gettimeofday(&amp;amp;tv, NULL);
    printf(&amp;quot;time: %ld: %ld\n&amp;quot;, tv.tv_sec, tv.tv_usec);

    sleep(1);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在linux下编译&lt;code&gt;gcc time.c -lrt&lt;/code&gt;&lt;/p&gt;
</description>
                <link>/linux/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E6%97%B6%E9%97%B4%E5%87%BD%E6%95%B0.html</link>
                <guid>/linux/Linux系统编程时间函数</guid>
                <pubDate>2013-07-01T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>影响linux适时性的因素以及相应的改进方法</title>
                <description>&lt;h4&gt;1.linux系统的实时性分析&lt;/h4&gt;

&lt;p&gt;Linux作为一个通用操作系统，主要考虑的是调度的公平性和吞吐量等指标。然而，在实时方面它还不能很好地满足实时系统方面的需要，其本身仅仅提供 了一些实时处理的支持，这包括支持大部分POSIX标准中的实时功能，支持多任务、多线程，具有丰富的通信机制等;同时也提供了符合POSIX标准的调度策略，包括FIFO调度策略、时间片轮转调度策略和静态优先级抢占式调度策略。Linux区分实时进程和普通进程，并采用不同的调度策略。&lt;/p&gt;

&lt;p&gt;为了同时支持实时和非实时两种进程，Linux的调度策略简单讲就是优先级加上时间片。当系统中有实时进程到来时，系统赋予它最高的优先级。体现在实时性上，Linux采用了两种简单的调度策略，即先来先服务调度(SCHED-FIFO)和时间片轮转调度(SCHED-RR)。具体是将所有处于运行状 态的任务挂接在一个run-queue 队列中,并将任务分成实时和非实时任务，对不同的任务，在其任务控制块task-struct中用一个policy属性来确定其调度策略。对实时性要求较 严的硬实时任务采用SCHED-FIFO调度，使之在一次调度后运行完毕。对普通非实时进程，Linux采用基于优先级的轮转策略。&lt;/p&gt;

&lt;h4&gt;2 普通linux影响实时性的因素&lt;/h4&gt;

&lt;h5&gt;2.1 时钟精度&lt;/h5&gt;

&lt;p&gt;普通Linux系统的时钟中断周期为10ms，无法满足实时系统较高精度的调度要求。在实时Linux应用中，需要细化其时钟粒度，具体有两种方式可以解决时钟粒度问题：一是通过直接修改内核定时参数HZ的初值来细化时钟粒度，如将标准Linux中内核定时参数HZ改为10000, 则时钟粒度可以达到100us，这种方式虽然会增加一些系统开销，但在强周期性环境下，对定时器的设置只需初始化一次，在一定程度上保证了处理效率;二是通过对可编程中断定时器8254或先进的可编程中断控制器进行编程来改进Linux时钟机制，以提高其时钟的分辨率，使毫秒级的粗粒度定时器变成微秒级的细粒度定时器。&lt;/p&gt;

&lt;h5&gt;2.2 核心态不可抢占&lt;/h5&gt;

&lt;p&gt;当一个任务通过系统调用进入内核态运行时,一个具有更高优先级的进程，只有等待处于核心态的系统调用返回后方能执行，这将导致优先级逆转。实时任务执行时间的不确定性，显然不能满足硬实时应用的要求。改善核心态的可抢占性，有两个主要的方向：中断管理的改进和互斥锁设计的改进（《改善Linux核心可抢占性方法的研究与实现》一文中提出，尚未理解）。还有一种方法是采用双内核，一个实时内核，一个普通内核。所有实时任务都由实时内核处理，普通内核作为最低级别的任务运行在实时内核上。&lt;/p&gt;

&lt;h5&gt;2.3 内存缺页异常&lt;/h5&gt;

&lt;p&gt;Linux采用虚拟内存管理技术进行内存管理，系统将最近未使用的代码和数据置换出内存，当需要时再从硬盘导入内存。这导致进程所需页面可能被置换出内存而不能及时响应，造成系统响应时间的不确定性。一种解决方案是预先分配内存，为每个实时任务分配固定的内存区域。另一种方案是在原有虚拟内存管理的基础上加上页面锁功能，将实时任务的页面加锁，这样就不会把实时任务的页面换出内存，提高实时任务的响应速度。&lt;/p&gt;

&lt;h5&gt;2.4 调度策略&lt;/h5&gt;

&lt;p&gt;Linux根据调度策略从整体上区分实时进程和普通进程，提供了三种条度方法。对于普通进程采用动态优先调度方法，根据剩余的时间片进行调整。对于实时进程采用FIFO（先来先服务）和RR（时间片轮转）调度，但这只能满足软实时任务的需要。当一个进程的一个时间片没有用完之前另一个即便是优先级高的进程也得不到响应。&lt;/p&gt;

&lt;p&gt;为了严格保证硬实时任务的时限要求，改善的Linux内核实时调度器采用了优先级调度算法，目前最小松弛时间优先调度算法MLF(Minimum- Laxity-First Scheduling Algorithm)是动态优先级调度最常见的实时调度策略。它在系统中为每一个任务设定松弛时间(任务的松弛时间等于任务的截止期减去任务执行时间、当前时间)即:laxity=deadline―current&lt;em&gt;time―CPU&lt;/em&gt;time&lt;em&gt;needed，系统优先执行具有最小松弛时间的任务。根据就绪队列的各任务的松弛时间来 分配优先级，松弛时间最小的任务具有最高的优先级。为了提高Linux的实时性，我们设计了MLF调度器，并把它作为可加载模块加入Linux内核中，在 实现中需对内核进行相应的修改。为了区分任务的类型，对基本Linux的task&lt;/em&gt;struct属性进行改进，在其中增加SCHED&lt;em&gt;MLF调度策略，并 按task&lt;/em&gt;struct中的policy的取值来进行区分, 分别用SCHED&lt;em&gt;MLF，SCHED&lt;/em&gt;RR，SCHED&lt;em&gt;OTHER来标识硬实时、软实时、非实时任务。将处于运行状态的三类任务放入两个队列，硬实时 任务放入hard&lt;/em&gt;real&lt;em&gt;queue队列, 采用MLF调度算法，软实时和非实时任务放入non&lt;/em&gt;real&lt;em&gt;queue队列(空闲任务也在其中)，沿用原内核的RR调度算法。这两个队列可以用一个 run&lt;/em&gt;queue[2]的指针数组来指向。&lt;/p&gt;

&lt;p&gt;双队列任务运行过程与原内核的单运行队列执行流程的主要区别在：首先，各硬实时任务采用了MLF调度算法代替原内核的FIFO调度，提高了 Linux系统的实时性能。其次，在判断是否有软中断需要处理之前需判断硬实时任务队列是否为空，如果不为空，即使存在中断的后半部分需要处理,也要先调 度硬实时任务投入运行，在硬实时队列为空的条件下才去处理中断的后半部分(因为中断的后半部分没有硬实时任务紧急)。最后，如果没有硬实时任务存在，则说 明只有run_queue [1]队列中有软实时或非实时任务存在，这时的处理方法和原内核对单运行队列的处理方法相同。这样改进后，可以明显提高硬实时任务的调度效率，而在没有硬 实时任务时，系统性能没有变化。&lt;/p&gt;

&lt;h5&gt;2.5 中断处理&lt;/h5&gt;

&lt;p&gt;Linux操作系统的外部中断大多是开启的，中断处理通常由设备驱动程序完成，系统将中断处理程序的优先级设定为高于任何用户进程。这种中断处理机制主要是基于通用操作系统的用户进程一般没有实时性要求，而中断处理程序与硬件设备直接交互，具有一定的实时性要求 。对于实时操作系统，用户进程都有实时性要求，设定中断处理程序优先级高于任何用户进程将不能满足实时性要求。另一方面对于发生频率不可预测的外部中断，用户程序被中断处理程序阻塞的时间开销也不可预测，从而影响了整个系统的可预测性。一种改进方法是采用中断软件模拟：当一个硬件中断发生时，系统只是简单的在事件表中报告这一事件的发生，然后立即将对CPU的使用权交给系统，而不是像一般的Linux系统那样去查找中断向量表并执行相应的中断服务程序。用中断的软件模拟相应的硬件处理，用软件的方法来检查每个中断时间的优先级，决定哪一个进程获得CPU使用权。&lt;/p&gt;
</description>
                <link>/rt-linux/%E5%BD%B1%E5%93%8Dlinux%E9%80%82%E6%97%B6%E6%80%A7%E7%9A%84%E5%9B%A0%E7%B4%A0%E4%BB%A5%E5%8F%8A%E7%9B%B8%E5%BA%94%E7%9A%84%E6%94%B9%E8%BF%9B%E6%96%B9%E6%B3%95.html</link>
                <guid>/rt-linux/影响linux适时性的因素以及相应的改进方法</guid>
                <pubDate>2013-06-11T00:00:00+08:00</pubDate>
        </item>


</channel>
</rss>
