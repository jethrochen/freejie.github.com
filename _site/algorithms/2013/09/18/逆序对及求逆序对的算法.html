<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<meta name="description" content="">
<meta name="author" content="CJ" />
<title>逆序对及求逆序对的算法</title>
<!-- Bootstrap core CSS -->
<link href="/bootstrap/dist/css/bootstrap.css" rel="stylesheet"
	media="screen">
<!-- Custom styles for this template -->
<link href="/css/cj.css" rel="stylesheet">
</head>

<body>

	<div class="navbar navbar-fixed-top navbar-inverse" role="navigation">
		<div class="container">
			<div class="navbar-header">
				<button type="button" class="navbar-toggle" data-toggle="collapse"
					data-target=".navbar-collapse">
					<span class="icon-bar"></span> <span class="icon-bar"></span> <span
						class="icon-bar"></span>
				</button>
				<a class="navbar-brand" href="/">CJ在路上</a>
			</div>
			<div class="collapse navbar-collapse">
				<ul class="nav navbar-nav">
					<li class="active"><a href="/">Home</a></li>
					<li><a href="#">Blog</a></li>
					<li><a href="/about.html">About</a></li>
					
				</ul>
			</div>
			<!-- /.nav-collapse -->
		</div>
		<!-- /.container -->
	</div>
	<!-- /.navbar -->

	

    <div class="container well well-lg">
    

            		<div><h3 id="section">逆序对及求逆序对的算法</h3>

<blockquote>
  <p><strong>逆序对：</strong><br />
设 A 为一个有 n 个数字的有序集 (n&gt;1)，其中所有数字各不相同。<br />
如果存在正整数 i, j 使得 1 ≤ i &lt; j ≤ n 而且 A[i] &gt; A[j]，则 &lt;A[i], A[j]&gt; 这个有序对就为 A 的一个逆序对，也称作逆序数。<br />
例如：数组 &lt;2,3,8,6,1&gt; 的逆序对为：&lt;2,1&gt; &lt;3,1&gt; &lt;8,6&gt; &lt;8,1&gt; &lt;6,1&gt; 总数共5个。  </p>
</blockquote>

<p>以上是来自维基百科对逆序对的定义。有定理：  </p>

<blockquote>
  <p><script type="math/tex">n</script>个不同的数做排列<script type="math/tex">p_1p_2p_3...p_n</script>，这个排列中逆序对的个数为  </p>
</blockquote>

<script type="math/tex; mode=display">
t = t_1 + t_2 + t_3 + ... + t_n = \sum_{i=1}^n{t_i}
</script>

<blockquote>
  <p><script type="math/tex">t_i</script>为排列中位于<script type="math/tex">p_i</script>前且小于<script type="math/tex">p_i</script>的数的个数  </p>
</blockquote>

<p>根据此定理,很容易求出一个排列中逆序数的个数，例如：排列 2 5 3 9 7 6 中，<script type="math/tex">t_1=0,t_2=0,t_3=1,t_4=0,t_5=1,t_6=2</script>,这个排列中逆序数的个数为<script type="math/tex">0+0+1+0+1+2=4</script>。<br />
这个可以作为求逆序对个数的基本算法  </p>

<div class="highlight"><pre><code class="cpp"><span class="lineno"> 1</span> <span class="kt">int</span> <span class="nf">nixu</span><span class="p">(</span><span class="kt">int</span> <span class="n">arr</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="lineno"> 2</span> <span class="p">{</span>
<span class="lineno"> 3</span>     <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
<span class="lineno"> 4</span>     <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="lineno"> 5</span> 
<span class="lineno"> 6</span>     <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="lineno"> 7</span>     <span class="p">{</span>
<span class="lineno"> 8</span>         <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">i</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span>
<span class="lineno"> 9</span>         <span class="p">{</span>
<span class="lineno">10</span>             <span class="k">if</span> <span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
<span class="lineno">11</span>                 <span class="n">sum</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
<span class="lineno">12</span>         <span class="p">}</span>
<span class="lineno">13</span>     <span class="p">}</span>
<span class="lineno">14</span> 
<span class="lineno">15</span>     <span class="k">return</span> <span class="n">sum</span><span class="p">;</span>
<span class="lineno">16</span> <span class="p">}</span>
</code></pre></div>

<p>很容易得到这个算法的时间复杂度是<script type="math/tex">\Theta(n^2)</script>。
在《算法导论》第2章有个思考题是关于逆序对的，问插入排序的运行时间和输入数组中逆序对的个数是什么关系，这个不难证明，两者是相等的。简单说明如下：<br />
将数字<script type="math/tex">a</script>插入升序排列的数组<script type="math/tex">a_1a_2...a_n</script>中，需要先在数组中找到要插入的位置，假设<script type="math/tex">% <![CDATA[
a_i<a<a_{i+1} %]]></script>,则<script type="math/tex">a_{i+1}a_{i+2}...a_n</script>都需要依此向后移动一个位置，移动的次数为<script type="math/tex">n-i</script>。而序列<script type="math/tex">a_1a_2...a_na</script>的逆序对的个数<script type="math/tex">n-i</script>，和插入排序移动的次数是相等的。因此对插入排序算法稍加改造就可以用来求序列的逆序对个数，但时间复杂度同样是<script type="math/tex">\Theta(n^2)</script>，所以有必要考虑其他的方法。<br />
书上提到了用归并排序算法，归并排序的时间复杂度是<script type="math/tex">\Theta(nlgn)</script>。理解了分治法的原理，再参考归并排序，这个问题很好解决。<br />
<strong>分解：</strong>将待分析序列分为<script type="math/tex">L</script>和<script type="math/tex">R</script>两部分。<br />
<strong>解决：</strong>原序列的逆序对个数为<script type="math/tex">f(A)</script>，分解后两个序列的逆序对个数分别为<script type="math/tex">f(L)</script>和<script type="math/tex">f(R)</script>，有<script type="math/tex">f(A)=f(L)+f(R)+S(L,R)</script>，其中<script type="math/tex">S(R)</script>为L和R共同构成的逆序对的个数。<script type="math/tex">f(L)</script>和<script type="math/tex">f(R)</script>可以递归分解至求单个元素的序列逆序对个数，<script type="math/tex">S(L,R)</script>可在合并的时候求出。<br />
<strong>合并：</strong>将两个已经求出逆序对个数并且完成排序的序列合并。  </p>

<div class="highlight"><pre><code class="cpp"><span class="lineno"> 1</span> <span class="cp">#include &lt;stdio.h&gt;</span>
<span class="lineno"> 2</span> 
<span class="lineno"> 3</span> <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="c1">//用于逆序对的计数</span>
<span class="lineno"> 4</span> 
<span class="lineno"> 5</span> <span class="kt">void</span> <span class="nf">merge</span><span class="p">(</span><span class="kt">int</span> <span class="n">A</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">m</span><span class="p">,</span> <span class="kt">int</span> <span class="n">q</span><span class="p">)</span>
<span class="lineno"> 6</span> <span class="p">{</span>
<span class="lineno"> 7</span>     <span class="kt">int</span> <span class="n">L</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span>
<span class="lineno"> 8</span>     <span class="kt">int</span> <span class="n">R</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span>
<span class="lineno"> 9</span>     <span class="kt">int</span> <span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">;</span>
<span class="lineno">10</span>     <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="lineno">11</span> 
<span class="lineno">12</span>     <span class="n">l</span> <span class="o">=</span> <span class="n">m</span> <span class="o">-</span> <span class="n">p</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="lineno">13</span>     <span class="n">r</span> <span class="o">=</span> <span class="n">q</span> <span class="o">-</span> <span class="n">m</span><span class="p">;</span>
<span class="lineno">14</span>     <span class="k">while</span><span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">l</span><span class="p">)</span>
<span class="lineno">15</span>         <span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">p</span><span class="o">+</span><span class="n">i</span><span class="p">];</span>
<span class="lineno">16</span>     <span class="k">while</span><span class="p">(</span><span class="n">j</span> <span class="o">&lt;</span> <span class="n">r</span><span class="p">)</span>
<span class="lineno">17</span>         <span class="n">R</span><span class="p">[</span><span class="n">j</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">m</span><span class="o">+</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
<span class="lineno">18</span> 
<span class="lineno">19</span>     <span class="n">i</span> <span class="o">=</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="lineno">20</span>     <span class="k">while</span><span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">l</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">r</span><span class="p">)</span>
<span class="lineno">21</span>     <span class="p">{</span>
<span class="lineno">22</span>         <span class="k">if</span> <span class="p">(</span><span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">R</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
<span class="lineno">23</span>             <span class="n">A</span><span class="p">[</span><span class="n">p</span><span class="o">+</span><span class="n">i</span><span class="o">+</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">];</span>
<span class="lineno">24</span>         <span class="k">else</span> 
<span class="lineno">25</span>         <span class="p">{</span>
<span class="lineno">26</span> 			<span class="n">count</span> <span class="o">+=</span> <span class="p">(</span><span class="n">l</span><span class="o">-</span><span class="n">i</span><span class="p">);</span>		<span class="c1">//计算R中每个元素的逆序数</span>
<span class="lineno">27</span>             <span class="n">A</span><span class="p">[</span><span class="n">p</span><span class="o">+</span><span class="n">i</span><span class="o">+</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">R</span><span class="p">[</span><span class="n">j</span><span class="o">++</span><span class="p">];</span>
<span class="lineno">28</span>         <span class="p">}</span>
<span class="lineno">29</span>     <span class="p">}</span>
<span class="lineno">30</span>     <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">l</span><span class="p">)</span>
<span class="lineno">31</span>         <span class="n">A</span><span class="p">[</span><span class="n">p</span><span class="o">+</span><span class="n">i</span><span class="o">+</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">];</span>
<span class="lineno">32</span>     <span class="k">while</span> <span class="p">(</span><span class="n">j</span> <span class="o">&lt;</span> <span class="n">r</span><span class="p">)</span>
<span class="lineno">33</span>         <span class="n">A</span><span class="p">[</span><span class="n">p</span><span class="o">+</span><span class="n">i</span><span class="o">+</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">R</span><span class="p">[</span><span class="n">j</span><span class="o">++</span><span class="p">];</span>
<span class="lineno">34</span> <span class="p">}</span>
<span class="lineno">35</span> 
<span class="lineno">36</span> 
<span class="lineno">37</span> <span class="kt">void</span> <span class="nf">get_inversion_by_mergesort</span><span class="p">(</span><span class="kt">int</span> <span class="n">A</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">l</span><span class="p">,</span> <span class="kt">int</span> <span class="n">r</span><span class="p">)</span>
<span class="lineno">38</span> <span class="p">{</span>
<span class="lineno">39</span>     <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="lineno">40</span> 
<span class="lineno">41</span> 	<span class="k">if</span> <span class="p">(</span><span class="n">l</span> <span class="o">&lt;</span> <span class="n">r</span><span class="p">)</span>
<span class="lineno">42</span>     <span class="p">{</span>
<span class="lineno">43</span>         <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">l</span> <span class="o">+</span> <span class="n">r</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
<span class="lineno">44</span>         <span class="n">get_inversion_by_mergesort</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">mid</span><span class="p">);</span>
<span class="lineno">45</span>         <span class="n">get_inversion_by_mergesort</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">mid</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>
<span class="lineno">46</span>         <span class="n">merge</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">mid</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>
<span class="lineno">47</span>     <span class="p">}</span>
<span class="lineno">48</span> <span class="p">}</span>
<span class="lineno">49</span> 
<span class="lineno">50</span> <span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="lineno">51</span> <span class="p">{</span>
<span class="lineno">52</span>     <span class="kt">int</span> <span class="n">A</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">};</span>
<span class="lineno">53</span> 
<span class="lineno">54</span>     <span class="n">get_inversion_by_mergesort</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">9</span><span class="p">);</span>
<span class="lineno">55</span>     <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
<span class="lineno">56</span> 	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="lineno">57</span> 		<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d &quot;</span><span class="p">,</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="lineno">58</span> 
<span class="lineno">59</span>     <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="lineno">60</span> <span class="p">}</span>
</code></pre></div>

</div>

		<div>
			<h2>Related Posts</h2>
			<ul class="posts">
				
				<li><span>17 Oct 2013</span> &raquo; <a
					href="/algorithms/2013/10/17/%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E9%97%AE%E9%A2%98.html">最大子数组问题</a></li> 
				<li><span>08 Sep 2013</span> &raquo; <a
					href="/algorithms/2013/09/08/%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0%E4%B9%8B%E8%BE%97%E8%BD%AC%E7%9B%B8%E9%99%A4%E6%B3%95.html">最大公约数之辗转相除法</a></li> 
				<li><span>16 Jul 2013</span> &raquo; <a
					href="/2013/07/16/C%E8%AF%AD%E8%A8%80%E4%B8%AD%E6%9D%A1%E4%BB%B6%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4.html">C语言中条件预处理指令</a></li> 
			</ul>
		</div>


    </div>

	<div class="footer"></div>
	<!-- end footers -->

<!-- support Math -->
<script type="text/javascript" src="//bootstrap/dist/js/MathJax.js"></script>

	<!-- Bootstrap core JavaScript -->
	<script src="/bootstrap/dist/js/jquery-latest.js"></script>
	<script src="/bootstrap/dist/js/bootstrap.js"></script>

</body>
</html>
