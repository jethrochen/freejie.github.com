
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>最大子数组问题</title>
    
    <meta name="author" content="Chen Jie">

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <!-- Le styles -->
    <link href="/assets/themes/twitter/css/1.4.0/bootstrap.css" rel="stylesheet">
    <link href="/assets/themes/twitter/css/style.css?body=1" rel="stylesheet" type="text/css" media="all">

    <!-- Le fav and touch icons -->
  <!-- Update these with your own images
    <link rel="shortcut icon" href="images/favicon.ico">
    <link rel="apple-touch-icon" href="images/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="72x72" href="images/apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="114x114" href="images/apple-touch-icon-114x114.png">
  -->
  </head>

  <body>

    <div class="topbar">
      <div class="fill">
        <div class="container">
          <a class="brand" href="/">Chen Jie</a>
          <ul class="nav">
            
            
            


  
    
      
    
  
    
      
      	
      	<li><a href="/archive.html">Archive</a></li>
      	
      
    
  
    
      
    
  
    
      
      	
      	<li><a href="/categories.html">Categories</a></li>
      	
      
    
  
    
      
    
  
    
      
      	
      	<li><a href="/pages.html">Pages</a></li>
      	
      
    
  
    
      
    
  
    
      
    
  
    
      
      	
      	<li><a href="/tags.html">Tags</a></li>
      	
      
    
  



          </ul>
        </div>
      </div>
    </div>

    <div class="container">

      <div class="content">
        
<div class="page-header">
  <h1>最大子数组问题 <small>Supporting tagline</small></h1>
</div>

<div class="row">
  <div class="span10">
    <p><strong>最大子数组</strong>是一道经典的面试题目，面试中遇到的概率比较大，正好在算法导论中有讨论，在这里做个总结。    </p>

<p><strong>问题描述：</strong>在给定的一个数组中，找到一个连续的子数组，使其和最大。就拿算法导论中的例子，给定数组为A[16]={13,-3,-25,20,-3,-16,-23,18,20,-7,12,-5,-22,15,-4,7}。</p>

<p><strong>问题分析解决：</strong>有多种方法可以解决这个问题，下面一下几种常见的方法并分析他们各自的算法复杂度。</p>

<h4 id="section">1.最简单粗暴的方法——穷举。</h4>
<p>列举出所有可能的连续组合，分别求出其和。这种方法但凡学过数学的都能想到且解决，其时间复杂度为<script type="math/tex">\Theta(n^2)</script>。这里就不讨论这种方法了，只给出程序用于验证以下方法的结果。    </p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;limits.h&gt;

void getMaxSubarray(int a[], int len, int *low, int *high, int *maxsum)
{
    int i, j;
    int sum;
    
    *maxsum = INT_MIN;
    for (i = 0; i &lt; len; ++i)
    {
        sum = 0;
        for (j = i; j &lt; len; ++j)
        {
            sum += a[j];
            if (*maxsum &lt; sum)
            {
                *maxsum = sum;
                *low = i; 
                *high = j;
            }
        }
    }
}

int main(void)
{
    int a[16] = {13,-3,-25,20,-3,-16,-23,18,20,-7,12,-5,-22,15,-4,7};
    int low, high, maxsum;

    getMaxSubarray(a, 16, &amp;low, &amp;high, &amp;maxsum);

    printf("the sum of maximum-subarray is %d\n", maxsum);
    printf("the index word of maximum-subarray is from %d to %d\n",
            low, high);

    return 0;
}
</code></pre>

<h4 id="section-1">2.分治策略求解</h4>
<p><strong>分解：</strong>假设A[low…high]是A[p…r]的最大子数组。容易理解，对于数组A[p…q]和A[q+1…r]，A[low…high]必然且仅符合下列情况之一：    </p>

<ul>
  <li>p&lt;=low&lt;=high&lt;=q，即A[low…high]是A[p…q]的最大子数组    </li>
  <li>q+1&lt;=high&lt;=low&lt;=r，即A[low…high]是A[q+1…r]的最大子数组    </li>
  <li>low&lt;=q且q+1&lt;=high。    </li>
</ul>

<p><strong>解决：</strong>  <br />
A[p…q]和A[q+1…r]可继续分解，所以只需要解决情况三即可。  <br />
在上述情况三中，A[low…high]可以分为两部分：A[low…q]和A[q+1…high]。而A[low…q]是以q为右边界的和最大的子数组，A[q+1…high]是以q+1为左边界的和最大的子数组。分别求出这两部分，得到low和high的值就OK了。伪代码如下：    </p>

<div class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">FIND</span><span class="o">-</span><span class="n">MAX</span><span class="o">-</span><span class="n">CROSSING</span><span class="o">-</span><span class="n">SUBARRAY</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">p</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">r</span><span class="p">)</span>
    <span class="n">leftsum</span> <span class="o">=</span> <span class="n">MIN_INT</span>
    <span class="n">temp</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="n">q</span> <span class="n">downto</span> <span class="n">p</span>
        <span class="n">temp</span> <span class="o">=</span> <span class="n">temp</span> <span class="o">+</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">temp</span> <span class="o">&gt;</span> <span class="n">leftsum</span>
            <span class="n">leftsum</span> <span class="o">=</span> <span class="n">temp</span>
            <span class="n">low</span> <span class="o">=</span> <span class="n">i</span>
    <span class="n">rightsum</span> <span class="o">=</span> <span class="n">MIN_INT</span>
    <span class="n">temp</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">j</span> <span class="o">=</span> <span class="n">q</span><span class="o">+</span><span class="mi">1</span> <span class="n">to</span> <span class="n">r</span>
        <span class="n">temp</span> <span class="o">=</span> <span class="n">temp</span> <span class="o">+</span> <span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">temp</span> <span class="o">&gt;</span> <span class="n">rightsum</span>
            <span class="n">rightsum</span> <span class="o">=</span> <span class="n">temp</span>
            <span class="n">high</span> <span class="o">=</span> <span class="n">j</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="p">,</span> <span class="n">leftsum</span><span class="o">+</span><span class="n">rightsum</span><span class="p">)</span></code></pre></div>

<p><strong>合并：</strong>  <br />
先分别递归求出A[low…(high+low)/2]、A[(high+low)/2+1…high]以及两者交叉部分的最大子数组的和left-sum、right-sum、cross-sum，然后比较得出三者最大的，对应的最大子数组就是所要求的最大字数组。伪代码如下：</p>

<div class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">FIND</span><span class="o">-</span><span class="n">MAXIMUM</span><span class="o">-</span><span class="n">SUBARRAY</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">low</span><span class="p">,</span><span class="n">high</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">high</span> <span class="o">==</span> <span class="n">low</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="p">,</span> <span class="n">A</span><span class="p">[</span><span class="n">low</span><span class="p">])</span>
    <span class="k">else</span> <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">low</span><span class="o">+</span><span class="n">high</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>
        <span class="p">(</span><span class="n">left</span><span class="o">-</span><span class="n">low</span><span class="p">,</span> <span class="n">left</span><span class="o">-</span><span class="n">high</span><span class="p">,</span> <span class="n">left</span><span class="o">-</span><span class="n">sum</span><span class="p">)</span> <span class="o">=</span> <span class="n">FIND</span><span class="o">-</span><span class="n">MAXIMUM</span><span class="o">-</span><span class="n">SUBARRAY</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">low</span><span class="p">,</span> <span class="n">mid</span><span class="p">)</span>
        <span class="p">(</span><span class="n">right</span><span class="o">-</span><span class="n">low</span><span class="p">,</span> <span class="n">right</span><span class="o">-</span><span class="n">high</span><span class="p">,</span> <span class="n">right</span><span class="o">-</span><span class="n">sum</span><span class="p">)</span> <span class="o">=</span> <span class="n">FIND</span><span class="o">-</span><span class="n">MAXIMUM</span><span class="o">-</span><span class="n">SUBARRAY</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">mid</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">high</span><span class="p">)</span>
        <span class="p">(</span><span class="n">cross</span><span class="o">-</span><span class="n">low</span><span class="p">,</span> <span class="n">cross</span><span class="o">-</span><span class="n">high</span><span class="p">,</span> <span class="n">cross</span><span class="o">-</span><span class="n">sum</span><span class="p">)</span> <span class="o">=</span> <span class="n">FIND</span><span class="o">-</span><span class="n">MAX</span><span class="o">-</span><span class="n">CROSSING</span><span class="o">-</span><span class="n">SUBARRAY</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">low</span><span class="p">,</span> <span class="n">mid</span><span class="p">,</span> <span class="n">high</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">left</span><span class="o">-</span><span class="n">sum</span> <span class="o">&gt;=</span> <span class="n">right</span><span class="o">-</span><span class="n">sum</span> <span class="o">&amp;&amp;</span> <span class="n">left</span><span class="o">-</span><span class="n">sum</span> <span class="o">&gt;=</span> <span class="n">cross</span><span class="o">-</span><span class="n">sum</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">left</span><span class="o">-</span><span class="n">low</span><span class="p">,</span> <span class="n">left</span><span class="o">-</span><span class="n">high</span><span class="p">,</span> <span class="n">left</span><span class="o">-</span><span class="n">sum</span><span class="p">)</span>
    <span class="n">esleif</span> <span class="n">right</span><span class="o">-</span><span class="n">sum</span> <span class="o">&gt;=</span> <span class="n">left</span><span class="o">-</span><span class="n">sum</span> <span class="o">&amp;&amp;</span> <span class="n">right</span><span class="o">-</span><span class="n">sum</span> <span class="o">&gt;=</span> <span class="n">cross</span><span class="o">-</span><span class="n">sum</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">right</span><span class="o">-</span><span class="n">low</span><span class="p">,</span> <span class="n">right</span><span class="o">-</span><span class="n">high</span><span class="p">,</span> <span class="n">right</span><span class="o">-</span><span class="n">sum</span><span class="p">)</span>
    <span class="k">else</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">cross</span><span class="o">-</span><span class="n">low</span><span class="p">,</span> <span class="n">cross</span><span class="o">-</span><span class="n">high</span><span class="p">,</span> <span class="n">cross</span><span class="o">-</span><span class="n">sum</span><span class="p">)</span></code></pre></div>

<p>C语言实现代码如下：</p>

<div class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cp">#include &lt;stdlib.h&gt;</span>
<span class="cp">#include &lt;limits.h&gt;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">KeyNum</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">low</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">high</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">maxsum</span><span class="p">;</span>
<span class="p">}</span> <span class="n">KeyNum</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">findCrossMaxSubarray</span><span class="p">(</span><span class="kt">int</span> <span class="n">array</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">left</span><span class="p">,</span> <span class="kt">int</span> <span class="n">right</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mid</span><span class="p">,</span> <span class="n">KeyNum</span> <span class="o">*</span><span class="n">key</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">leftsum</span> <span class="o">=</span> <span class="n">INT_MIN</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">rightsum</span> <span class="o">=</span> <span class="n">INT_MIN</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">mid</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">left</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">temp</span> <span class="o">+=</span> <span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">leftsum</span> <span class="o">&lt;</span> <span class="n">temp</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">leftsum</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
            <span class="n">key</span><span class="o">-&gt;</span><span class="n">low</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">temp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">right</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">temp</span> <span class="o">+=</span> <span class="n">array</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">rightsum</span> <span class="o">&lt;</span> <span class="n">temp</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">rightsum</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
            <span class="n">key</span><span class="o">-&gt;</span><span class="n">high</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">key</span><span class="o">-&gt;</span><span class="n">maxsum</span> <span class="o">=</span> <span class="n">leftsum</span> <span class="o">+</span> <span class="n">rightsum</span><span class="p">;</span>

<span class="p">}</span>

<span class="n">KeyNum</span> <span class="nf">findMaximumSubarray</span><span class="p">(</span><span class="kt">int</span> <span class="n">array</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">left</span><span class="p">,</span> <span class="kt">int</span> <span class="n">right</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">mid</span><span class="p">;</span>
    <span class="n">KeyNum</span> <span class="n">leftkey</span><span class="p">,</span> <span class="n">rightkey</span><span class="p">,</span> <span class="n">crosskey</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">left</span> <span class="o">&gt;=</span> <span class="n">right</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">leftkey</span><span class="p">.</span><span class="n">low</span> <span class="o">=</span> <span class="n">left</span><span class="p">;</span>
        <span class="n">leftkey</span><span class="p">.</span><span class="n">high</span> <span class="o">=</span> <span class="n">left</span><span class="p">;</span>
        <span class="n">leftkey</span><span class="p">.</span><span class="n">maxsum</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="n">left</span><span class="p">];</span>
        <span class="k">return</span> <span class="n">leftkey</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">left</span> <span class="o">+</span> <span class="n">right</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
    <span class="n">leftkey</span> <span class="o">=</span> <span class="n">findMaximumSubarray</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">mid</span><span class="p">);</span>
    <span class="n">rightkey</span> <span class="o">=</span> <span class="n">findMaximumSubarray</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">mid</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">right</span><span class="p">);</span>
    <span class="n">findCrossMaxSubarray</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">mid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">crosskey</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">leftkey</span><span class="p">.</span><span class="n">maxsum</span> <span class="o">&gt;</span><span class="n">rightkey</span><span class="p">.</span><span class="n">maxsum</span> <span class="o">&amp;&amp;</span> <span class="n">leftkey</span><span class="p">.</span><span class="n">maxsum</span> <span class="o">&gt;</span> <span class="n">crosskey</span><span class="p">.</span><span class="n">maxsum</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">leftkey</span><span class="p">;</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">rightkey</span><span class="p">.</span><span class="n">maxsum</span> <span class="o">&gt;</span> <span class="n">leftkey</span><span class="p">.</span><span class="n">maxsum</span> <span class="o">&amp;&amp;</span> <span class="n">rightkey</span><span class="p">.</span><span class="n">maxsum</span> <span class="o">&gt;</span> <span class="n">crosskey</span><span class="p">.</span><span class="n">maxsum</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">rightkey</span><span class="p">;</span>
    <span class="k">else</span>
        <span class="k">return</span> <span class="n">crosskey</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="mi">16</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">13</span><span class="p">,</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span><span class="o">-</span><span class="mi">25</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span><span class="o">-</span><span class="mi">16</span><span class="p">,</span><span class="o">-</span><span class="mi">23</span><span class="p">,</span><span class="mi">18</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span><span class="o">-</span><span class="mi">7</span><span class="p">,</span><span class="mi">12</span><span class="p">,</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span><span class="o">-</span><span class="mi">22</span><span class="p">,</span><span class="mi">15</span><span class="p">,</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span><span class="mi">7</span><span class="p">};</span>
    <span class="n">KeyNum</span> <span class="n">key</span><span class="p">;</span>

    <span class="n">key</span><span class="p">.</span><span class="n">low</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">key</span><span class="p">.</span><span class="n">high</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">key</span><span class="p">.</span><span class="n">maxsum</span> <span class="o">=</span> <span class="n">INT_MIN</span><span class="p">;</span>

    <span class="n">key</span> <span class="o">=</span> <span class="n">findMaximumSubarray</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">15</span><span class="p">);</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;the sum of maximum-subarray is %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">key</span><span class="p">.</span><span class="n">maxsum</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;the index word of maximum-subarray is from %d to %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
            <span class="n">key</span><span class="p">.</span><span class="n">low</span><span class="p">,</span> <span class="n">key</span><span class="p">.</span><span class="n">high</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre></div>

<h4 id="thetan">3.还有一种更精妙的方法，算法复杂度竟然达到了<script type="math/tex">\Theta(n)</script></h4>
<p>先看代码吧，过把眼瘾。  </p>

<div class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="nf">getMaxSubarray</span><span class="p">(</span><span class="kt">int</span> <span class="n">array</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">sum</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">low</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">high</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">temp</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

    <span class="n">temp</span> <span class="o">=</span> <span class="o">*</span><span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="o">*</span><span class="n">low</span> <span class="o">=</span> <span class="o">*</span><span class="n">high</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">temp</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
            <span class="o">*</span><span class="n">low</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span> 
        <span class="p">{</span>
            <span class="n">temp</span> <span class="o">+=</span> <span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
            <span class="o">*</span><span class="n">high</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">sum</span> <span class="o">&lt;</span> <span class="n">temp</span><span class="p">)</span>
            <span class="o">*</span><span class="n">sum</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre></div>


    <hr>
    <div class="pagination">
      <ul>
      
        <li class="prev"><a href="/algorithms/2013/09/08/%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0%E4%B9%8B%E8%BE%97%E8%BD%AC%E7%9B%B8%E9%99%A4%E6%B3%95" title="最大公约数之辗转相除法">&larr; Previous</a></li>
      
        <li><a href="/archive.html">Archive</a></li>
      
        <li class="next"><a href="/algorithms/2013/11/04/%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF%E9%97%AE%E9%A2%98" title="约瑟夫环问题">Next &rarr;</a></li>
      
      </ul>
    </div>
    <hr>
    


  <div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_developer = 1;
    var disqus_shortname = 'jekyllbootstrap'; // required: replace example with your forum shortname
    
    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">blog comments powered by <span class="logo-disqus">Disqus</span></a>




  </div>
  
  <div class="span4">
    <h4>Published</h4>
    <div class="date"><span>17 October 2013</span></div>

  
    <h4>Tags</h4>
    <ul class="tag_box">
    
    


  
     
    	<li><a href="/tags.html#algorithms-ref">algorithms <span>2</span></a></li>
     
    	<li><a href="/tags.html#最大字数组和-ref">最大字数组和 <span>1</span></a></li>
    
  



    </ul>
    
  </div>
</div>


      </div>

      <footer>
        <p>&copy; Chen Jie 2012 
          with help from <a href="http://jekyllbootstrap.com" target="_blank" title="The Definitive Jekyll Blogging Framework">Jekyll Bootstrap</a>
          and <a href="http://twitter.github.com/bootstrap/" target="_blank">Twitter Bootstrap</a>
        </p>
      </footer>

    </div> <!-- /container -->

    
  </body>
</html>

